Не используйте return в Scala
=============================

Сегодня я бы хотел представить вашему вниманию перевод небольшой статьи Роберта Норриса, известного псевдонимом [tpolecat](https://github.com/tpolecat?tab=repositories). Роберт контрибьютит в [cats](https://github.com/typelevel/cats), а также разрабатывает [doobie](https://github.com/tpolecat/doobie). Оригинал статьи вы можете найти по [ссылке](https://tpolecat.github.io/2014/05/09/return.html).

В этой статье автор рассказывает о том как использование `return` может негативно повлиять на семантику вашего кода, а также проливает свет на ряд интересных технических особенностей реализации `return` в Scala.

<cut text="Так чем так плох retrun?">

В общем, каждый раз, когда на Coursera запускается курс Мартина, у нас на **#scala** появляются люди, спрашивающие почему из-за `return` у них отнимаются очки стиля. Итак, вот совет:

> ключевое слово `return` не является "необязательным" или "выводимым". Оно изменяет значение вашей программы, и вам не следует его использовать.

Рассмотрим небольшой пример:

    // Сложим два Int'а, и используем этот метод чтобы просуммировать список
    def add(n:Int, m:Int): Int = n + m
    def sum(ns: Int*): Int = ns.foldLeft(0)(add)

    scala> sum(33, 42, 99)
    res0: Int = 174

    // Тоже, используя return
    def addR(n:Int, m:Int): Int = return n + m
    def sumR(ns: Int*): Int = ns.foldLeft(0)(addR)

    scala> sumR(33, 42, 99)
    res1: Int = 174

Все в порядке, и между `sum` и `sumR` нет очевидной разницы, что может навести вас на мысль, что `return` является просто необязательным ключевым словом. Давайте слегка отрефакторим оба метода, и добавим в них немного инлайнинга:

    // проинлайнен add
    def sum(ns: Int*): Int = ns.foldLeft(0)((n, m) => n + m)

    scala> sum(33, 42, 99)
    res2: Int = 174 // вполне..

    // проинлайнен addR
    def sumR(ns: Int*): Int = ns.foldLeft(0)((n, m) => return n + m)

    scala> sumR(33, 42, 99)
    res3: Int = 33 // Хм...


**Какого..?!**
Итак, если кратко то:

> Когда поток управления доходит до выражения `return`, вычисление текущего выражения прекращается, вместо этого происходит (немедленный) возврат из того *метода*, в теле которого находится этот return.

Так, в вышеприведенном примере оператор `return` не возвращает значение из анонимной функции. Он возвращает значение из *метода*, внутри которого находится. Еще пример:

    def foo: Int = {
      val sumR: List[Int] => Int = _.foldLeft(0)((n, m) => return n + m)
      sumR(List(1,2,3)) + sumR(List(4,5,6))
    }

    scala> foo
    res4: Int = 1


**Нелокальный возврат**
Когда значение функции содержит `return` оно выполняется нелокально, вычисление прекращается и результат возвращается путем **возбуждения** (throwing) `NonLocalReturnControl[A]`. Эта деталь реализации бесцеремонно от нас ускользает:

    def lazily(s: => String): String =
      try s catch { case t: Throwable => t.toString }

    def foo: String = lazily("foo")
    def bar: String = lazily(return "bar")

    scala> foo
    res5: String = foo

    scala> bar
    res6: String = scala.runtime.NonLocalReturnControl

Для тех кто скажет, что `Throwable` не следует отлавливать в любом случае, я скажу, что не следует использовать исключения для контроля потока исполнения. Глупость вроде `breakable { ... }` из стандартной библиотеки, эксплуатирующая схожую технику также не должна использоваться.

Другой пример. А что если оператор `return` захватывается, но не выполняется пока возвращаемый метод не вернется? Ну, теперь у вас есть бомба замедленного действия которая рванет, когда выполнится:

    scala> def foo: () => Int = () => return () => 1
    foo: () => Int

    scala> val x = foo
    x: () => Int = <function0>

    scala> x()
    scala.runtime.NonLocalReturnControl

И, в качестве дополнительного бонуса, `NonLocalReturnControl` наследуется от `NoStackTrace` так что у вас не будет улик о том где и когда бомба была изготовлена. Хорошая штука.


**Каков тип возвращаемого значения?**
В `return a` **возвращаемое** выражение должно соответствовать типу возвращаемого метода, в котором оно появляется, однако выражение `return a` само по себе имеет тип и из его семантики "прекратить дальнейшие вычисления" вы, должно быть, догадались какой тип оно имеет. Если нет, вот вам чутка просвещения:

    def x: Int = { val a: Int = return 2; 1 } // результат 2

Оно проходит проверку типов, так что наше предположение может заключаться в том, что тип `return a` совпадает с типом `a`. Итак, давайте проверим эту теорию, попробовав что-то что не должно работать:

    def x: Int = { val a: String = return 2; 1 }

Хм, это тоже. Что происходит? Чем бы ни был тип `return 2`, он он определенно является как `Int`, так и `String`. И так как оба эти класса являются `final`, а `Int` по совместительству еще и `AnyVal`, вы знаете где это происходит.

    def x: Int = { val a: Nothing = return 2; 1 }

Правильно. Всякий раз, сталкиваясь с `Nothing`, вам было бы благоразумнее развернуться и пойти другой дорогой. Так как Nothing — необитаем (не существует ни одного значения этого типа), понятно, что и выражение не имеет никакой нормальной формы. Такое выражение, при попытке его вычислить, обязано либо начать бесконечный цикл, либо завершить виртуальную машину, либо (методом исключений) передать управление куда-либо еще, что мы и можем тут наблюдать.

Если ваша реакция: "логически вы вызываете [продолжение](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)), что мы все время делаем в Scheme, и я не вижу в этом проблемы"" то хорошо, вам печенька. Остальные из нас думают что это безумие.


**Return нарушает ссылочную прозрачность.**
Это само собой разумеется, однако если вы не очень уверенны в этом, я продемонстрирую:

    def foo(n:Int): Int = {
      if (n < 100) n else return 100
    }

затем я должен бы был переписать свою программу без изменения смысла так:

    def foo(n: Int): Int = {
      val a = return 100
      if (n < 100) n else a
    }

что конечно, не сработает. Выполнение `return` порождает побочный эффект.


**Но что, если мне это _действительно_ нужно?**
Не нужно. Если вы окажетесь в ситуации где вам, по вашему мнению нужно досрочно завершить выполнение, вам необходимо переосмыслить способ объявления вашего выражения. Например:

    // Добавляем числа в список до 100 максимум
    def max100(ns: List[Int]): Int =
      ns.foldLeft(0) { (n, m) =>
        if (n + m > 100)
          return 100
        else
          n + m
      }

может быть переписано с использованием простой хвостовой рекурсии:

    // Добавляем числа в список до 100 максимум
    def max100(ns: List[Int]): Int = {
      def go(ns: List[Int], a: Int): Int =
        if (a >= 100) 100
        else ns match {
          case n :: ns => go(ns, n + a)
          case Nil     => a
        }
      go(ns, 0)
    }

Это **всегда** возможно. Устранение `return` из языка Scala приведет к появлению пустых программ которые, более не смогут быть написаны. Изменить мышление возможно будет не просто, однако, в конце вы обнаружите что написание выражений которые заканчиваются должным образом намного проще, чем попытки рассуждать о побочных эффектах проявляющиеся как нелокальное управление потоком исполнения.
