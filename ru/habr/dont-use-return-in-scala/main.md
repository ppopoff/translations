Не используйте return в Scala
=============================

Сегодня я бы хотел представить вашему вниманию перевод небольшой статьи Роберта Норриса, известного под псевдонимом [tpolecat](https://github.com/tpolecat?tab=repositories), достаточно широко известного по его вкладу в [cats](https://github.com/tpolecat/cats) и [doobie](https://github.com/tpolecat/doobie). Оригинал статьи вы можете найти по [ссылке](https://tpolecat.github.io/2014/05/09/return.html).

В этой статье автор рассказывает о том, как использование `return` может негативно повлиять на семантику вашего кода, а также проливает свет на ряд интересных технических особенностей реализации `return` в Scala.

<cut text="Так чем так плох retrun?">

Итак, каждый раз, когда на Coursera запускают курс Мартина, у нас на **#scala** появляются люди, вопрошающие, почему за `return` с них снимаются очки стиля. Поэтому, вот вам ценный совет:

> Ключевое слово `return` не является «необязательным» или «подразумевающимся» по контексту — оно меняет смысл вашей программы, и вам никогда не следует его использовать.

Взглянем на этот небольшой пример:

    // Сложим в методе два инта и используем его, чтобы просуммировать список.
    def add(n: Int, m: Int): Int = n + m
    def sum(ns: Int*): Int = ns.foldLeft(0)(add)

    scala> sum(33, 42, 99)
    res0: Int = 174

    // То же самое, но используя return.
    def addR(n:Int, m:Int): Int = return n + m
    def sumR(ns: Int*): Int = ns.foldLeft(0)(addR)

    scala> sumR(33, 42, 99)
    res1: Int = 174

Пока что все в порядке. Между `sum` и `sumR` нет очевидной разницы, что может навести вас на мысль о том, что `return` является просто необязательным ключевым словом. Но давайте слегка отрефакторим оба метода, вручную заинлайнив `add` и `addR`:

    // Заинлайнили add.
    def sum(ns: Int*): Int = ns.foldLeft(0)((n, m) => n + m)

    scala> sum(33, 42, 99)
    res2: Int = 174 // вполне..

    // Заинлайнили addR.
    def sumR(ns: Int*): Int = ns.foldLeft(0)((n, m) => return n + m)

    scala> sumR(33, 42, 99)
    res3: Int = 33 // Хм...

**Какого...?!**

Если кратко, то:

> Когда поток управления доходит до выражения `return`, текущие вычисления прекращаются и происходит немедленный возврат из того *метода*, в теле которого находится return.

Так, в нашем примере оператор `return` не возвращает значение из анонимной функции — он возвращает значение из *метода*, внутри которого находится. Еще пример:

    def foo: Int = {
      val sumR: List[Int] => Int = _.foldLeft(0)((n, m) => return n + m)
      sumR(List(1,2,3)) + sumR(List(4,5,6))
    }

    scala> foo
    res4: Int = 1


## Нелокальный возврат

Когда функциональный объект, содержащий вызов `return`, выполняется нелокально, прекращение вычислений и возврат результата из него выполняются путём **возбуждения исключения** `NonLocalReturnControl[A]`. Эта деталь реализации легко и без особых церемоний просачивается наружу:


    def lazily(s: => String): String =
      try s catch { case t: Throwable => t.toString }

    def foo: String = lazily("foo")
    def bar: String = lazily(return "bar")

    scala> foo
    res5: String = foo

    scala> bar
    res6: String = scala.runtime.NonLocalReturnControl

Если кто-то возразит, что перехватывать `Throwable` -- дурной тон, я могу ему отвечить, что дурной тон -- использовать исключения для управления потоком исполнения. Глупость под названием `breakable { ... }` из стандартной библиотеки устроена аналогичным образом и, аналогично return, не должна никогда использоваться.

Другой пример. Что если оператор `return` оказывается замкнут в лямбда-выражение,  которое остаётся живо даже после того, как его родной метод отработал? Ну, теперь в вашем распоряжении бомба замедленного действия, которая рванет при попытке использования.

    scala> def foo: () => Int = () => return () => 1
    foo: () => Int

    scala> val x = foo
    x: () => Int = <function0>

    scala> x()
    scala.runtime.NonLocalReturnControl

Дополнительным бонусом прилагается тот факт, что `NonLocalReturnControl` наследуется от `NoStackTrace`, поэтому у вас не будет никаких улик о том, где эта бомба была изготовлена. Классная штука.


## Какой тип у `return`?
В `return a` **возвращаемое** выражение `a` должно соответствовать тому типу, который возвращает его родной метод, однако выражение `return a` и само по себе имеет тип. Исходя из его смысла «прекратить дальнейшие вычисления», вы, должно быть, догадались какой тип оно имеет. Если нет, вот вам чутка просвещения:

    def x: Int = { val a: Int = return 2; 1 } // результат 2

Видите, анализатор типов не ругается, так что можем предположить, что тип выражения `return a` всегда совпадает с типом `a`. Давайте теперь проверим эту теорию, попробовав написать что-то, что не должно работать:

    def x: Int = { val a: String = return 2; 1 }

Хм, тоже не ругается. Что вообще происходит? Каким бы ни был тип `return 2`, должен быть приводимым к `Int` и `String` одновременно. А так как оба эти класса являются `final`, а `Int` — еще и `AnyVal`, вы знаете, к чему всё это идёт.

    def x: Int = { val a: Nothing = return 2; 1 }

Именно так, это Nothing. А всякий раз, сталкиваясь с `Nothing`, вам было бы благоразумнее развернуться и пойти другой дорогой. Так как Nothing — необитаем (не существует ни одного значения этого типа), понятно, что и выражение не имеет никакой нормальной формы. Такое выражение, при попытке его вычислить, обязано либо начать бесконечный цикл, либо завершить виртуальную машину, либо (методом исключений) передать управление куда-либо еще, что мы и можем тут наблюдать.

Если вы сейчас подумали: «Вообще-то, в этом примере мы, по-логике, всего-лишь вызываем [продолжение](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)), мы *постоянно* так делаем в Scheme, и я совершенно не вижу тут проблемы», хорошо. Вот вам печенька. Все, кроме вас, тут думают, что это безумие.


## Return нарушает ссылочную прозрачность
Это, как бы, очевидно. Но вдруг вы не совсем в курсе, что эти слова означают. Так вот, если у меня есть такой код:

    def foo(n:Int): Int = {
      if (n < 100) n else return 100
    }

то, будь он ссылочно корректным, я был бы вправе переписать его без изменения смысла вот таким образом:

    def foo(n: Int): Int = {
      val a = return 100
      if (n < 100) n else a
    }

Конечно, он не будет работать: выполнение `return` порождает побочный эффект.


## Но что, если мне это _действительно_ нужно?
Не нужно. Если вы окажетесь в ситуации, когда вам, по вашему мнению, нужно досрочно покинуть метод, на самом деле вам нужно перепроектировать структуру кода. Например, такое:

    // Складываем числа из списка пока их сумма меньше 100.
    def max100(ns: List[Int]): Int =
      ns.foldLeft(0) { (n, m) =>
        if (n + m > 100)
          return 100
        else
          n + m
      }

может быть переписано с использованием простой хвостовой рекурсии:

    // Добавляем числа в список до 100 максимум
    def max100(ns: List[Int]): Int = {
      def go(ns: List[Int], a: Int): Int =
        if (a >= 100) 100
        else ns match {
          case n :: ns => go(ns, n + a)
          case Nil     => a
        }
      go(ns, 0)
    }

Это **всегда** возможно. Полное устранение оператора `return` из языка не увеличит множество программ, которые невозможно написать на Scala, и на единицу. Вам может потребоваться немного усилий над собой, чтобы принять это, но в результате вы поймёте, что куда проще писать код без преждевременных возвратов, чем ломать голову в попыткать предсказать побочные эффекты, вызванные нелокальными возвратами потока управления.
