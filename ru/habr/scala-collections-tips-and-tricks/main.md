Секреты и трюки Scala коллекций
===============================

<img src="https://pavelfatin.com/images/scala-collections.jpg"
     style="float:left">

Представляю вашему вниманию перевод статьи
[Павла Фатина](https://pavelfatin.com/about) [Scala Collections Tips and Tricks](https://pavelfatin.com/scala-collections-tips-and-tricks/). Павел работает в [JetBrains](https://www.jetbrains.com/) и занимается разработкой [Scala плагина](https://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA) для IntelliJ IDEA.

В этой статье представлен перечень упрощений и оптимизаций для типичного использования [API Scala коллекций](https://www.scala-lang.org/docu/files/collections-api/collections.html).

Некоторые советы основаны на тонких деталях реализации библиотеки коллекций, однако, большинство рецептов являются разумными преобразованиями, которые, на практике, часто упускаются из виду.

Этот список вдохновлен моими попытками разработать практичные [инспекции для Scala коллекций](https://youtrack.jetbrains.com/oauth?state=%2Fissues%2FSCL%3Fq%3Dby%253A%2BPavel.Fatin%2Bcollection%2Border%2Bby%253A%2Bcreated) для [Scala плагина IntelliJ](https://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA). Сейчас мы в процессе внедрения данных инспекций, так что если вы используете этот плагин в IDEA вы автоматически выиграите от статического анализа кода.

Тем не менее, эти рецепты ценны сами по себе и могут помочь вам углубить ваше понимание стандартной библиотеки коллекций Scala и сделать ваш код быстрее и чище.

===
**Обновление:**
Если вы испытываете тягу к приключениям,
вы можете узнать как помочь в развитии IntelliJ плагина для Scala
и попробовать свои силы в "доступных всем желающим" в понравившихся вам инспекций для коллекций

If you feel adventurous,
you can learn how to contribute to IntelliJ Scala plugin
and try your hand at “up for grabs” collection inspections that are to your liking.
===

<cut text="Читать далее →">


**Содержание:**

  1. Легенда
  2. Композиция
  3. Побочные эффекты
  4. Последовательности (Sequences)
    4.1. Создание
    4.2. Длина
    4.3. Равенство
    4.4. Индексация
    4.5. Существование
    4.6. Фильтрация
    4.7. Сортировка
    4.8. Свертка
    4.9. Сопоставление
    4.10. Перерабатываем
  5. Множества (Sets)
  6. Option-ы
    6.1. Значение
    6.2. Null
    6.3. Обработка
    6.4. Перерабатываем
  7. Maps
  8. Дополнение

Все примеры кода доступны в [репозитории на GitHub](https://github.com/pavelfatin/scala-collections-tips-and-tricks).


## 1. Легенда
Чтобы сделать примеры кода более понятными, я придерживался следующих условных обозначений:

  * `seq` — экземпляр основанной на `Seq` коллекции, вроде `Seq(1, 2, 3)`
  * `set` — экземпляр `Set`, например `Set(1, 2, 3)`
  * `array` — массив, такой как `Array(1, 2, 3)`
  * `option` — экземпляр `Option`, например, `Some(1)`
  * `map` — экземпляр `Map`, подобный `Map(1 -> "foo", 2 -> "bar")`
  * `???` — произвольное выражение
  * `p` — предикат функции типа `T => Boolean`, например `_ > 2`
  * `n` — целочисленное значение
  * `i` — целочисленный индекс
  * `f`, `g` — простые функции, `A => B`
  * `x`, `y` — некоторые произвольные значения
  * `z` — начальное, или значение по-умолчанию
  * `P` — паттерн

## 2. Композиция
Имейте в виду, что несмотря на то что все рецепты изолированны и самодостаточны, мы можем скомпоновать их, для того чтобы итеративно превратить их в более продвинутые выражения, например:

    seq.filter(_ == x).headOption != None

    // от seq.filter(p).headOption к seq.find(p)
    seq.find(_ == x) != None

    // от option != None к option.isDefined
    seq.find(_ == x).isDefined

    // от seq.find(p).isDefined к seq.exists(p)
    seq.exists(_ == x)

    // от seq.exists(_ == x) к seq.contains(x)
    seq.contains(x)

Таким образом, мы можем полагаться на "заменяющую модель применения рецептов" (по аналогии с [SICP](https://mitpress.mit.edu/sicp/full-text/sicp/book/node10.html)) для упрощения сложных выражений.

## 3. Побочные эффекты
"Побочный эффект" (Side effect) является основной концепцией, которую следует рассмотреть перед перечислением основных преобразований.

В основном, побочным эффектом является любое действие, которое помимо возврата значения, можно наблюдать за пределами функции или выражения, например:

  * операция ввода-вывода,
  * модификация переменной (доступной за пределами области видимости),
  * изменение состояния объекта (наблюдаемое вне области видимости),
  * возбуждение исключения (которое также не обрабатывается внутри области видимости).

О функциях или выражениях содержащих любое из вышеперечисленных действий, говорят, что они имеют побочные эффекты, в противном случае их называют «чистыми».

Почему побочные эффекты так важны? Потому что при их наличии, порядок исполнения имеет значение. Например, два «чистых» выражения, (связанных с соответствующими значениями):

    val x = 1 + 2
    val y = 2 + 3

Поскольку они не содержат побочных эффектов (т.е. эффектов, наблюдаемых вне выражений), мы можем фактически вычислить эти выражения в любом порядке — сначала `x`, а затем `y`, или сначала `y`, а затем `x` — это не повлияет на корректность полученных результатов (мы можем даже закешировать результирующие значения, если того захотим). Теперь, рассмотрим следующую модификацию:

    val x = { print("foo"); 1 + 2 }
    val y = { print("bar"); 2 + 3 }

Это уже другая история — мы не можем изменить порядок выполнения, так  вместо "foobar" в нашем терминале будет напечатано "barfoo" (и это не то, что мы ожидали).

Таким образом, присутствие побочных эффектов **уменьшает количество возможных преобразований** (включая упрощения и оптимизации), которые мы можем применить к коду.

Подобные рассуждения могут быть применены и к выражениям связанным с коллекциями. Представим, что у нас есть некий `builder` вне области видимости, (с методом `append`, имеющим побочный эффект).

    seq.filter(x => { builder.append(x); x > 3 }).headOption

В принципе, конструкция `seq.filter(p).headOption` сводится к вызову `seq.find(p)`, однако наличие побочного эффекта не позволяет нам это сделать:

    seq.find( x => {builder.append(x); x > 3 })

Хотя эти выражения и эквивалентны с точки зрения результирующего значения, они не эквивалентны в отношении побочных эффектов. В первом выражении будут добавлены все элементы, в то время как в последнем будут пропущены все элементы после первого совпадения с предикатом. Таким образом, подобное упрощение не может быть выполнено.

Что можно сделать, чтобы сделать автоматическое упрощение стало возможными? Ответ — **золотое правило**, которое должно быть применено ко всем побочным эффектам в наше коде (включая код, не имеющий коллекций совсем):

  * Избегать побочных эффектов, когда это возможно
  * Иначе, изолировать побочные эффекты от чистого кода.

Поэтому, мы необходимо либо избавиться от `builder`а (вместе с его API, содержащим побочные эффекты), или отделить вызов `builder`а от чистого выражения. Предположим, что этот  `builder` является неким сторонним объектом, от которого мы не можем избавиться, поэтому изолируем вызов:

    seq.foreach(builder.append)
    seq.filter(_ > 3).headOption

Теперь мы можем безопасно выполнить преобразование:

    seq.foreach(builder.append)
    seq.find(x > 3)

Чисто и красиво! Изоляция побочных эффектов делает автоматические преобразования возможными. Дополнительным преимуществом является то, что в виду наличия чистого разделения, результирующий код легче понять человеку.

Наименее очевидным, однако наиболее важным преимуществом изоляции побочных эффектов будет повышение надежности нашего кода, относительно других возможных оптимизаций. Применительно к примеру, первоначальное выражение может порождать различные побочные эффекты зависящие от текущей реализации `Seq`. Для `Vector`, например, оно добавит все элементы, для `Stream` оно пропустит все элементы после первого удачного сопоставления с предикатом (потому что стримы «ленивы» — элементы вычисляются только тогда, когда это необходимо). Изоляция побочных эффектовпозволяет нам избежать этого неопределенного поведения.


## 4. Последовательности (Sequences)
Хотя представленные в этом разделе советы и относятся преимущественно  к наследникам `Seq`, некоторые преобразования применимы и к другим классам коллекций (и не только), например `Set`, `Option`, `Map` и даже `Iterator` (потому что все они предоставляют похожие интерфейсы с монадическими методами).

### 4.1 Создание
#### Создавайте пустые коллекции явно

    // До
    Seq[T]()

    // После
    Seq.empty[T]

Некоторые неизменяемые (immutable) классы коллекций имеют синглтон-реализацию метода `empty`. Однако, далеко не все фабричные методы проверяют длину созданных коллекций. Таким образом, делая пустоту очевидной на этапе компиляции, вы можете сохранить либо место в куче (путем переиспользования экземпляра), либо такты процессора (потраченные бы на проверки размерности во время выполнения). Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

### 4.2 Длины
#### Используйте `length` вместо `size` для массивов

    // До
    array.size

    // После
    array.length

Несмотря на то что, `size` и `length` являются практически синонимами, в Scala 2.11 вызовы `Array.size` по прежнему выполняются через неявное преобразование (implicit conversion), таким образом создаются промежуточные объекты-обертки для каждого вызова метода. Если вы конечно не включите [эскейп анализ](https://en.wikipedia.org/wiki/Escape_analysis) для JVM, подобные временные объекты будут обузой для сборщика мусора и деградируют производительность кода (особенно внутри циклов).

#### Не отрицайте isEmpty

    // До
    !seq.isEmpty
    !seq.nonEmpty

    // После
    seq.nonEmpty
    seq.isEmpty

Простые свойства добавляют меньше визуального шума, нежели составные выражения.
Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Не вычисляйте длину при проверке на пустоту.

    // До
    seq.length > 0
    seq.length != 0
    seq.length == 0

    // После
    seq.nonEmpty
    seq.nonEmpty
    seq.isEmpty

С одной стороны, простое свойство воспринимается гораздо легче, нежели составное выражение. С другой стороны, для коллекций-наследников `LinearSeq` (таких как `List`) может потребоваться `O(n)` времени на вычисление длин списка (вместо `O(1)` для `IndexedSeq`), таким образом мы можем ускорить наш код избегая вычисления длины когда нам вобщем-то, это значение и не нужно.
Имейте также в виду, что вызов `.length` для бесконечных стримов может никогда не закончиться, поэтому всегда проверяйте стрим на пустоту явно.
Также применимо к: `Set`, `Map`.

### Не вычисляйте полную длину коллекции при сравнении

    // До
    seq.length > n
    seq.length < n
    seq.length == n
    seq.length != n

    // После
    seq.lengthCompare(n) > 0
    seq.lengthCompare(n) < 0
    seq.lengthCompare(n) == 0
    seq.lengthCompare(n) != 0

Поскольку вычисление размера коллекции может быть достаточно «дорогостоящим» вычислением для некоторых классов коллекций, мы можем сократить время сравнения с `O(length)` до `O(length min n)` для наследников `LinearSeq` (которые могут быть спрятаны под `Seq`-подобными значениями).
Кроме того, подобный подход незаменим если имеем дело с бесконечными стримами.


### Не используйте `exists` для проверки на пустоту

    // До
    seq.exists(_ => true)
    seq.exists(const(true))

    // После
    seq.nonEmpty

Разумеется, такой трюк будет совсем излишним.
Также применимо к: Set, Option, Map, Iterator.

### 4.3 Равенство
#### Не полагайтесь на `==` для сравнения содержания массивов

    // До
    array1 == array2

    // После
    array1.sameElements(array2)

Проверка на равенство всегда будет выдавать `false` для различных экземпляров массивов.
Также применимо к: `Iterator`.

#### Не проверяйте на равенство коллекции различных категорий

    // До
    seq == set

    // После
    seq.toSet == set

Проверки на равенство могут быть использованы для сравнения коллекций и различных категорий (например `List` и `Set`).
Прошу вас дважды подумать о смысле данной проверки (касательно примера выше — как рассматривать дубликаты в последовательности).

#### Не используйте `sameElements` для сравнения обычных коллекций

    // До
    seq1.sameElements(seq2)

    // После
    seq1 == seq2

Проверка равенства это способ, которым следует сравнивать коллекции одной и той же категории. В теории, это может улучшить производительность из-за наличия возможных низлежащих проверок экземпляра (`eq`, обычно намного быстрее).


#### Не используйте corresponds явно

    // До
    seq1.corresponds(seq2)(_ == _)

    // После
    seq1 == seq2

У нас уже есть встроенный метод, который делает тоже самое. Оба выражения принимают во внимание порядок элементов. И мы опять-таки сможем извлечь пользу от повышения производительности.

## 4.4 Индексация
#### Не получайте первый элемент по индексу

    // До
    seq(0)

    // После
    seq.head

Обновленный подход может быть немного быстрее для некоторых типов коллекций (ознакомьтесь с кодом `List.apply`, например). Кроме того, доступ к свойству намного проще (как синтаксически, так и семантически), чем вызов метода с аргументом.

#### Не получайте последний элемент по индексу

    // До
    seq(seq.length - 1)

    // После
    seq.last

Последнее выражение является более очевидным и при этом позволяет избежать избыточного вычисления длины коллекции (а для линейных последовательностей это может занять немало времени). Более того, некоторые классы коллекций могут извлекать последний элемент более эффективно, в сравнении с доступом по индексу.

#### Не проверяйте нахождение индекса в границах коллекции явно

    // До
    if (i < seq.length) Some(seq(i)) else None

    // После
    seq.lift(i)

Семантически, второе выражение эквивалентно, однако более выразительно

#### Не эмулируйте headOption

    // До
    if (seq.nonEmpty) Some(seq.head) else None
    seq.lift(0)

    // После
    seq.headOption

Оптимизированное выражение более лаконично.

#### Не эмулируйте `lastOption`

    // До
    if (seq.nonEmpty) Some(seq.last) else None
    seq.lift(seq.length - 1)

    // После
    seq.lastOption

Оптимизированное выражение короче (и потенциально быстрее).

#### Будьте осторожны с типами аргументов для `indexOf` и `lastIndexOf`

    // До
    Seq(1, 2, 3).indexOf("1") // скомпилируется
    Seq(1, 2, 3).lastIndexOf("2") // скомпилируется

    // После
    Seq(1, 2, 3).indexOf(1)
    Seq(1, 2, 3).lastIndexOf(2)

В виду особенностей работы [вариантности](http://stackoverflow.com/questions/2078246/why-does-seq-contains-accept-type-any-rather-than-the-type-parameter-a/2078619#2078619), методы `indexOf` и `lastIndexOf` принимают аргументы типа `Any`. На практике, это может приводить к труднонаходимым багам, которые невозможно обнаружить на этапе компиляции. Вот где вспомогательные инспекции вашей IDE придуться к месту.

#### Не создавайте диапазон индексов последовательности вручную

    // До
    Range(0, seq.length)

    // После
    seq.indices

Существует встроенный метод, который возвращает диапазон из всех индексов последовательности.

#### Не используйте zip для связывания коллекции с индексами вручную

    // До
    seq.zip(seq.indices)

    // После
    seq.zipWithIndex

Во-первых, последнее выражение короче. Кроме того, мы можем ожидать некоторый прирост производительности, так как мы избегаем скрытого вычисления размера коллекции (что, в случае линейных последовтаельностей может обойтись недешево).
Дополнительное преимущество последнего выражения в том что оно хорошо работает с возможно бесконечными коллекциями (например `Stream`).

#### Используйте экземпляр IndexedSeq как объект-функцию:

    // До (seq: IndexedSeq[T])
    Seq(1, 2, 3).map(seq(_))

    // После
    Seq(1, 2, 3).map(seq)

Поскольку экземпляр `IndexedSeq[T]` также является `Function1[Int, T]`, вы можете использовать его как таковой.

### 4.5 Существование
#### Не используйте предикат сравнения, для проверки наличия элемента

    // До
    seq.exists(_ == x)

    // После
    seq.contains(x)

Второе выражение семантически эквивалентно, однако более выразительно. Когда эти выражения используются применительно к `Set`, производительность может значительно отличаться, из-за того что поиск у множеств стремится к O(1) (из-за внутреннего индексирования, не использующегося при вызове `exists`).
Также применимо к: `Set`, `Option`, `Iterator`.

#### Будьте осторожны с типом аргумента `contains`

    // До
    Seq(1, 2, 3).contains("1") // компилируется

    // После
    Seq(1, 2, 3).contains(1)

Так же как методы `indexOf` и `lastIndexOf`, `contains` принимает аргументы типа `Any`, что может привести к труднонаходимым багам, которые не находятся на этапе компиляции. Будьте осторожны с аргументами этих методов.

#### Не используйте предикат неравенства для проверки отсутствия элемента

    // До
    seq.forall(_ != x)

    // После
    !seq.contains(x)

И снова последнее выражение чище и, вероятно быстрее (особенно для множеств).
Также применимо к: `Set`, `Option`, `Iterator`.

#### Не считайте вхождения для проверки существования

    // До
    seq.count(p) > 0
    seq.count(p) != 0
    seq.count(p) == 0

    // После
    seq.exists(p)
    seq.exists(p)
    !seq.exists(p)

Очевидно, когда нам нужно знать, содержится ли удовлетворяющий предикату элемент в коллекции, подсчет количества удовлетворяющих элементов будет излишним. Оптимизированное выражение выглядит чище и работает быстрее.
 - Предикат `p` должен быть чистой функцией.
 - Также применимо к: `Set`, `Map`, `Iterator`.

#### Не прибегайте к фильтрации для проверки существования

    // До
    seq.filter(p).nonEmpty
    seq.filter(p).isEmpty

    // После
    seq.exists(p)
    !seq.exists(p)

Вызов `filter` создает промежуточную коллекцию, которая занимает место в куче и нагружает GC. Кроме того, первые выражения находят все вхождения, в то время как требуется найти только первое (что может замедлить код, в зависимости от вероятного содержимого коллекции). Потенциальный выигрыш в производительности менее значим для ленивых коллекций (таких как `Stream`, и в особенности `Iterator`).

 - Предикат `p` должен быть чистой функцией.
 - Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Не прибегайте к поиску чтобы проверить существование

    // До
    seq.find(p).isDefined
    seq.find(p).isEmpty

    // После
    seq.exists(p)
    !seq.exists(p)

Поиск определенно лучше чем фильтрация, однако мы все еще можем сделать это лучше (по крайней мере, с точки зрения ясности).
Также применимо к: `Set`, `Option`, `Map`, `Iterator`.


### 4.6 Фильтрация
#### Не отрицайте предикат filter

    // До
    seq.filter(!p)

    // После
    seq.filterNot(p)

Последнее выражение синтактически проще (при том семантически они эквивалентны).
Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Не прибегайте к фильтрации чтобы посчитать элементы

    // До
    seq.filter(p).length

    // После
    seq.count(p)

Вызов `filter` создает промежуточную (не очень то и нужную) коллекцию, занимающую место в куче и нагружающую GC.
Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Не используйте фильтрацию для того чтобы найти первое вхождение

    // До
    seq.filter(p).headOption

    // После
    seq.find(p)

Если `seq` конечно не является ленивой коллекцией (как, например, `Stream`), фильтрация найдет все вхождения (и создаст временную коллекцию), в то время как требуется только первый элемент.
Также применимо к: `Set`, `Option`, `Map`, `Iterator`.


### 4.7 Сортировка
#### Не сортируйте по свойству вручную

    // До
    seq.sortWith(_.property <  _.property)

    // После
    seq.sortBy(_.property)

Для этого у нас есть специальный метод, более ясный и выразительный.

#### Не сортируйте по тождеству вручную

    // До
    seq.sortBy(identity)
    seq.sortWith(_ < _)

    // После
    seq.sorted

Для этого существует специальный метод.

#### Выполняйте обратную сортировку в один шаг

    // До
    seq.sorted.reverse
    seq.sortBy(_.property).reverse
    seq.sortWith(f(_, _)).reverse

    // После
    seq.sorted(Ordering[T].reverse)
    seq.sortBy(_.property)(Ordering[T].reverse)
    seq.sortWith(!f(_, _))

Таким образом мы можем избежать создания дополнительной коллекции и исключить дополнительные преобразования (для того чтобы сохранить место в куче и циклы процессора).

#### Не используйте сортировку для нахождения минимального элемента

    // До
    seq.sorted.head
    seq.sortBy(_.property).head

    // После
    seq.min
    seq.minBy(_.property)

Последний подход является наиболее выразительным. Более того, он более эффективен в виду того что не создается дополнительная коллекция.

#### Не используйте сортировку для нахождения максимального элемента

    // До
    seq.sorted.last
    seq.sortBy(_.property).last

    // После
    seq.max
    seq.maxBy(_.property)

Объяснение, такое же как и в предыдущем совете.


### 4.8 Свертка
#### Не вычисляйте сумму вручную

    // До
    seq.reduce(_ + _)
    seq.fold(z)(_ + _)

    // После
    seq.sum
    seq.sum + z

Преимуществами этого подхода являются ясность и выразительность.
 - Другие возможные методы: `reduceLeft`, `reduceRight`, `foldLeft`, `foldRight`.
 - Второе преобразование может быть заменено первым, если `z` равняется `0`.
 - Также применимо к: `Set`, `Iterator`.

#### Не вычисляйте продукцию вручную

    // До
    seq.reduce(_ * _)
    seq.fold(z)(_ * _)

    // После
    seq.product
    seq.product * z

Обоснование такое же как и в предыдущем случае.
 - Второе преобразование может быть заменено первым, если `z` равняется `1`.
 - Также применимо к: `Set`, `Iterator`.

#### Не ищите минимальный элемент вручную

    // До
    seq.reduce(_ min _)
    seq.fold(z)(_ min _)

    // После
    seq.min
    z min seq.min

Обоснование такое же как и в предыдущем случае.
Также применимо к: `Set`, `Iterator`.

#### Не выполняйте поиск максимального элемента вручную

    // До
    seq.reduce(_ max _)
    seq.fold(z)(_ max _)

    // После
    seq.max
    z max seq.max

Обоснование такое же как и в предыдущем случае.
Также применимо к: `Set`, `Iterator`.

#### Не эмулируйте `forall`

    // До
    seq.foldLeft(true)((x, y) => x && p(y))
    !seq.map(p).contains(false)

    // После
    seq.forall(p)

Целью упрощения является ясность и выразительность.

 - Предикат `p` должен быть чистой функцией.
 - Также применимо к: `Set`, `Option` (for the second line), `Iterator`.

#### Не эмулируйте `exists`

    // До
    seq.foldLeft(false)((x, y) => x || p(y))
    seq.map(p).contains(true)

    // После
    seq.exists(p)

Кроме того, при всей ясности и выразительности, последнее выражение может быть быстрее (потому что оно останаливает обработку элементов после нахождения первого вхождения), и может работать для бесконечных последовательностей.

 - Предикат `p` должен быть чистой функцией.
 - Также применимо к: `Set`, `Option` (for the second line), `Iterator`.

#### Не эмулируйте `map`

    // До
    seq.foldLeft(Seq.empty)((acc, x) => acc :+ f(x))
    seq.foldRight(Seq.empty)((x, acc) => f(x) +: acc)

    // После
    seq.map(f)

Это «классическая» реализация отображения (map) через светрку в функциональном программировании. Бесспорно, она является исключительно дидактической, нужды к ней прибегать нет. Для этого у нас есть встроенный и выразительный метод (который еще и быстрее, потому что использует под капотом простой цикл `while`).
Также применимо к: `Set`, `Option`, `Iterator`.

#### Не эмулируйте `filter`

    // До
    seq.foldLeft(Seq.empty)((acc, x) => if (p(x)) acc :+ x else acc)
    seq.foldRight(Seq.empty)((x, acc) => if (p(x)) x +: acc else acc)

    // После
    seq.filter(p)

Обоснование то же что и в предудущем случае.
Также применимо к: `Set`, `Option`, `Iterator`.

#### Не эмулируйте `reverse`

    // До
    seq.foldLeft(Seq.empty)((acc, x) => x +: acc)
    seq.foldRight(Seq.empty)((x, acc) => acc :+ x)

    // После
    seq.reverse

Опять-таки встроенный метод быстрее и чище.
Также применимо к: `Set`, `Option`, `Iterator`.


### 4.9 Сопоставление
Вот несколько обособленных советов, посвященных [сопоставлению с образцом](http://docs.scala-lang.org/tutorials/tour/pattern-matching.html) в Scala и [частичным функциям](https://www.scala-lang.org/api/current/index.html#scala.PartialFunction).


#### Используйте частичные функции вместо функций с паттерн матчингом

    // До
    seq.map {
      _ match {
        case P => ??? // x N
      }
    }

    // После
    seq.map {
      case P => ??? // x N
    }

Обновленное выражение порождает тот же результат, однако выглядит проще.

Возможно применить данные преобразования к любым функциям, не только к
аргументам функции `map`. Данный совет относится не только к коллекциям. Однако, в виду вездесущести [функций высшего порядка](https://en.wikipedia.org/wiki/Higher-order_function) в API стандартной библиотеки коллекций Scala, даный совет будет весьма кстати.

#### Конвертируйте `flatMap` с частичной функцией `collect`

    // До
    seq.flatMap {
      case P => Seq(???) // x N
      case _ => Seq.empty
    }

    // После
    seq.collect {
      case P => ??? // x N
    }

Обновленное выражение дает аналогичный результат, однако выглядит намного проще.
Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Преобразовать `match` к `collect` когда результатом является коллекция

    // До
    v match {
      case P => Seq(???) // x N
      case _ => Seq.empty
    }

    // После
    Seq(v) collect {
      case P => ??? // x N
    }

В то время как все case операторы создают коллекции, можно упростить выражение заменив оператор `match` на вызов `collect`. Таким образом мы можем создать коллекцию только раз, опустив при этом явные ветки `case` для случаев по умолчанию.
Лично, я обычно использую этот трюк с `Option`, нежели с последовательностями как таковыми.
Также применимо к: `Set`, `Option`, `Iterator`.

#### Не эмулируйте `collectFirst`

    // До
    seq.collect{case P => ???}.headOption

    // После
    seq.collectFirst{case P => ???}

Для подобного случая, у нас есть специальный метод который также работает быстрее для неленивых коллекций.
 - Частичная функция должна быть чистой.
 - Также применимо к: `Set`, `Map`, `Iterator`.


### 4.10 Перерабатываем
#### Соединяем последовательные вызовы `filter`

    // До
    seq.filter(p1).filter(p2)

    // После
    seq.filter(x => p1(x) && p2(x))

Так мы можем избежать создания промежуточной коллекции (после первого вызова `filter`), облегчив ношу сборщика мусора.
Мы так же можем применить обобщенный подход, полагающийся на использование представлений (смотрите ниже), получив: `seq.view.filter(p1).filter(p2).force`.

 - Предикаты `p1` и `p2` должны быть чистыми функциями.
 - Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Соединяем последовательные вызовы `map`

    // До
    seq.map(f).map(g)

    // После
    seq.map(f.andThen(g))

Опять мы напрямую создаем результирующую коллекцию, без создания промежуточной.

Мы так же можем применить обобщенный подход который полагается на использование view (смотрите ниже), получив: `seq.view.map(f).map(g).force`.

 - Функции `f` и `g` должны быть чистыми.
 - Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Сортируйте после фильтрации

    // До
    seq.sorted.filter(p)

    // После
    seq.filter(p).sorted

Сортировка является затратной по вычислимости процедурой. Поэтому нет нужды сортировать элементы которые будут потенциально отфильтрованны на следующем шаге.

 - Подобное применимо ко всем возможным методам сортировки, таким как `sortWith` и `sortBy`.
 - Предикат `p` должен быть чистой функцией.

#### Не переворачивайте коллекцию явно перед вызовом `map`

    // До
    seq.reverse.map(f)

    // После
    seq.reverseMap(f)

Первое выражение создает промежуточную (перевернутую) коллекцию перед преобразованием элементов, что иногда бывает достаточно разумным (например для `List`). В других случаях возможно непосредственно выполнить требуемые преобразования без создания промежуточной коллекции, что более эффективно.

#### Не переворачивайте коллекцию явно для получения обратного итератора

    // До
    seq.reverse.iterator

    // После
    seq.reverseIterator

К тому же последнее выражение проще и может быть более эффективным.

#### Не конвертируйте коллекцию `Set` для нахождения отдельных элементов

    // До
    seq.toSet.toSeq

    // После
    seq.distinct

Нет нужды создавать временное множество (во всяком случае явно), чтобы найти отдельные элементы.

#### Не эмулируйте `slice`

    // До
    seq.drop(x).take(y)

    // После
    seq.slice(x, x + y)

Для линейных последовательностей все что мы можем получить это лаконичность и ясно выраженные намерения. Однако, для индексированных последовательностей мы можем ожидать потенциальный прирост производительности.
Также применимо к: `Set`, `Map`, `Iterator`.

#### Не эмулируйте `splitAt`

    // До
    val seq1 = seq.take(n)
    val seq2 = seq.drop(n)

    // После
    val (seq1, seq2) = seq.splitAt(n)

Оптимизированное выражения исполняется быстрее для линейных последовательностей. (как для `List`, так и для `Stream`), в виду того что оно вычисляет результаты за один проход.
Также применимо к: `Set`, `Map`.

#### Не эмулируйте `span`

    // До
    val seq1 = seq.takeWhile(p)
    val seq2 = seq.dropWhile(p)

    // После
    val (seq1, seq2) = seq.span(p)

Вот как мы можем пройти последовательность и проверить предикат всего один раз, а не два.

 - Предикат `p` не должен иметь побочных эффектов.
 - Также применимо к: `Set`, `Map`, `Iterator`.

#### Не эмулируйте `partition`

    // До
    val seq1 = seq.filter(p)
    val seq2 = seq.filterNot(p)

    // После
    val (seq1, seq2) = seq.partition(p)

Опять-таки, преимуществом будет однопроходное вычисление
 - Предикат `p` не должен иметь побочных эффектов.
 - Также применимо к: `Set`, `Map`, `Iterator`.

#### Не эмулируйте `takeRight`

    // До
    seq.reverse.take(n).reverse

    // После
    seq.takeRight(n)

Последнее выражение является более выразительным и потенциально более эффективным (Как для индексированных, так и для линейных последовательностей).

#### Не эмулируйте `flatten`

    // До (seq: Seq[Seq[T]])
    seq.reduce(_ ++ _)
    seq.fold(Seq.empty)(_ ++ _)
    seq.flatMap(identity)

    // После
    seq.flatten

Нет необходимости вручную уплощать коллекции, когда для этого у нас уже есть специализированный метод.
Также применимо к: `Set`, `Option`, `Iterator`.

#### Не эмулируйте `flatMap`

    // До (f: A => Seq[B])
    seq.map(f).flatten

    // После
    seq.flatMap(f)

Опять-таки нет нужды эмулировать встроенный методы вручную. Помимо улучшения выразительности, мы пропускаем создание дополнительной коллекции.
Также применимо к: `Set`, `Option`, `Iterator`.

#### Не используйте `map` если результат игнорируется

    // До
    seq.map(???) // результат игнорируется

    // После
    seq.foreach(???)

Когда побочные эффекты это то что нам нужно, вызову `map` нет оправдания. Подобный вызов менее эффективен и способен ввести в заблуждение.
Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Не используйте `unzip` для извлечения единственного элемента

    // До (seq: Seq[(A, B]])
    seq.unzip._1

    // После
    seq.map(_._1)

Нет нужды порождать дополнительные коллекции когда требуется только один элемент.
 - Другой возможный метод: `unzip3`.
 - Также применимо к: `Set`, `Option`, `Map`, `Iterator`.

#### Не создавайте временные коллекции
Этот рецепт разделяется на три части (в зависимости от конечного результата преобразования).

1) Преобразования сокращают коллекцию до единственного значения.

    // До
    seq.map(f).flatMap(g).filter(p).reduce(???)

    // После
    seq.view.map(f).flatMap(g).filter(p).reduce(???)

Вместо `reduce` может быть любой метод который сокращает коллекцию до единого значения, например: `reduceLeft`, `reduceRight`, `fold`, `foldLeft`, `foldRight`, `sum`, `product`, `min`, `max`, `head`, `headOption`, `last`, `lastOption`, `indexOf`, `lastIndexOf`, `find`, `contains`, `exists`, `count`, `length`, `mkString`, и т.д.

Точный порядок преобразований не имеет значения — важно то, что мы создаем одну или несколько временных промежуточных коллекций, которые сами по себе не нужны, однако они будут отнимать место в куче и нагружать GC. Это происходит потому, что по умолчанию все трансформаторы коллекций (`map`, `flatMap`, `filter`, `++,` и т.д.) являются «строгими» (за исключением`Stream`) и как результат преобразования, создают новую коллекцию со всеми ее элементами.

Здесь на помощь приходят представления (view) — вы можете думать о них как о своего рода итераторах, которые позволяют повторную итерацию:
  * Представления "ленивы" — элементы создаются только когда необходимы.
  * Представления не содержат созданных элементов в памяти (чем грешат даже `Stream`).

Чтобы перейти от коллекции к ее виду, используйте метод `view`.

2) Трансформации порождающие коллекцию того же класса.

Можно использовать представления когда конечный результат трансформации все еще является коллекцией — метод `force` построит коллекцию оригинального класса (в то время как создание всех промежуточных коллекций по-прежнему избегается):

    // До
    seq.map(f).flatMap(g).filter(p)

    // После
    seq.view.map(f).flatMap(g).filter(p).force

Если единственной промежуточной трансформацией является фильтрация, то в качестве альтернативы вы можете рассмотреть метод `withFilter`:

    seq.withFilter(p).map(f)

Изначально, этот метод [предназначался](https://www.scala-lang.org/old/node/3698.html#comment-14546) для использования внутри "for comprehensions". Он работает так же как и представление — создавая временный объект который ограничивает область последующих преобразований коллекции (так что он реорганизует возможные побочные эффекты). Однако нет необходимости в явно преобразовывать коллекцию к / от временного представления (путем вызова `veiw` и `force`)

Хотя основанный на видах подход и является более универсальным, в данном конкретном случае вы можете предпочесть метод `withFilter` из-за его лаконичности.

3) Преобразование порождает коллекцию другого класса.

    // До
    seq.map(f).flatMap(g).filter(p).toList

    // После
    seq.view.map(f).flatMap(g).filter(p).toList

В этот раз мы используем подходящий метод-конвертер (вместо обобщенного вызова
`force`), поэтому результатом будет коллекция другого рода.

Также существует альтернативный способ совладать с «трансформацией + конверсией». Этот случай полагается на `breakOut`:

    seq.map(f)(collection.breakOut): List[T]

Подобное выражение функционально эквивалентно использованию представления, однако этот подход:

  * требует явного указания ожидаемого типа (что, зачастую, требует дополнительного указания типа),
  * ограничивается единичной трансформацией (как например `map`, `flatMap`, `filter`, `fold`, и т.д.),
  * выглядит довольно сложно (в виду того что неявные билдеры обычно [опускают](https://www.scala-lang.org/api/current/index.html#scala.collection.Seq) из документации стандартной библиотеки коллекций Scala).

Так что, как правило, лучше заменить `breakOut` на более гибкое и выразительнее представление.

Представления особенно эффективны при относительно большом размере коллекций.

 - Все перечисленные функции (как `f` и `g`) и предикаты (`p`) обязаны быть чистыми (в виду того что представление может задерживать, пропускать или переупорядочивать вычисления).
 - Также применимо к: `Set`, `Map`.

#### Используйте операторы для переприсванивания последовательностей

    // До
    seq = seq :+ x
    seq = x +: seq
    seq1 = seq1 ++ seq2
    seq1 = seq2 ++ seq1

    // После
    seq :+= x
    seq +:= x
    seq1 ++= seq2
    seq1 ++:= seq2

Scala предлагает синтаксический сахар, известный как «операторы присваивания» (“assignment operators”) — он автоматически приводит операторы типа `x <op>= y` к виду `x = x <op> y` где `<op>` некий символьный оператор (например `+`, `-`, и т.д). Обратите внимание, что если `<op>` заканчивается на `:` он считается право-ассоциативным (т.е. вызываетя для правого выражения, вместо левого). Так же существует специальный синтаксис для списков и стримов:

    // До
    list = x :: list
    list1 = list2 ::: list

    stream = x #:: list
    stream1 = stream2 #::: stream

    // После
    list ::= x
    list1 :::= list2

    stream #::= x
    stream1 #:::= stream2

Оптимизированные выражения лаконичней.
Также применимо к `Set`, `Map`, `Iterator` (учитывая специфику операторов).


#### Не приводите коллекции к заданному типу вручную

    // До
    seq.foldLeft(Set.empty)(_ + _)
    seq.foldRight(List.empty)(_ :: _)

    // После
    seq.toSet
    seq.toList

У нас есть соответствующие встроенные методы, которые и чище и быстрее. Если вам необходимо преобразовать или отфильтровать значения во время преобразования, рассмотрите использование представлений или аналогичных техник описанным выше. Также применимо к: `Set`, `Option`, `Iterator`.

#### Будьте осторожны в использовании `toSeq` для нестрогих коллекций.

    // До (seq: TraversableOnce[T])
    seq.toSeq

    // После
    seq.toStream
    seq.toVector

Так как `Seq(...)` создает строгую коллекцию (а именно, [Vector](https://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Vector)), у нас может возникнуть соблазн использовать `toSeq`, для преобразования нестрогой сущности (как `Stream`, `Iterator`, или `view`) к строгой коллекции. Однако, `TraversableOnce.toSeq` на самом деле возвращает  `Stream`, являющийся ленивой коллекцией, что может закончиться труднонаходимыми багами и проблемами с производительностью. Даже если стрим это именно то что вы ожидали, подобное выражение может ввести в заблуждение тех, кто читает ваш код.

А вот и типичный пример ловушки:

    val source = Source.fromFile("lines.txt")
    val lines = source.getLines.toSeq
    source.close()
    lines.foreach(println)

Подобный код выбросит `IOException` сетующее на то что stream уже закрыт.

Для того чтобы прояснить наши намерения, лучше добавить `toStream` явно или, если нам после всего потребуется строгая коллекция, использовать `toVector` вместо `toSeq`.

#### Не приводите к строковому типу вручную

    // До (seq: Seq[String])
    seq.reduce(_ + _)
    seq.reduce(_ + separator + _)
    seq.fold(prefix)(_ + _)
    seq.map(_.toString).reduce(_ + _) // seq: Seq[T]
    seq.foldLeft(new StringBuilder())(_ append _)

    // После
    seq.mkString
    seq.mkString(prefix, separator, "")

Последний подход чище и потенциально быстрее, потому что в своей реализации использует единственный `StringBuilder`.

 - Другие возможные методы: `reduceLeft`, `reduceRight`, `foldLeft`, `foldRight`.
 - Также применимо к: `Set`, `Option`, `Iterator`.


## 5. Множесва (Sets)
Большинство советов относящихся к последовательностям так же хорошо применимы и к множествам. Кроме того, есть несколько советов специфичных для множетв.

#### Не используйте `sameElements` для сравнения неупорядоченные коллекций

    // До
    set1.sameElements(set2)

    // После
    set1 == set2

Это правило было представлено ранее (для последовательностей), однако для множеств существует более здравое обоснование.

Метод `sameElements` может возвращать недетерминированные результаты для неупорядоченных коллекций, потому что этот метод принимает во внимание порядок элементов, на который мы не можем полагаться в случае с множествами.

Классы которые явно гарантируют предсказуемый порядок итерации, такие как `LinkedHashSet`, являются исключениями из данного правила.

Также применимо к: `Map`.

#### Используйте экземпляр Set как объект-функцию

    // До (set: Set[Int])
    Seq(1, 2, 3).filter(set(_))
    Seq(1, 2, 3).filter(set.contains)

    // После
    Seq(1, 2, 3).filter(set)

Так как `Set[T]` также явялется экземпляром `Function1[T, Boolean]`, вы можете использовать его в этому качестве.


#### Не вычисляйте пересечения множеств вручную

    // До
    set1.filter(set2.contains)
    set1.filter(set2)

    // После
    set1.intersect(set2) // или set1 & set2

Последнее выражение является более ясным и выразительным, (производительность аналогична).

Это преобразование может применено к последовательностям, однако, стоит учесть, что в подобном случае к дубликатам потребуется индивидуальный подход.

#### Не вычисляйте разницу множеств вручную

    // До
    set1.filterNot(set2.contains)
    set1.filterNot(set2)

    // После
    set1.diff(set2) // или set1 &~ set2

Опять же, обновленное выражение будет более ясными выразительным (в то время как производительность не изменится).

Данная трансформация потенциально применима и к последовательностям, однако нам следует учесть наличие дубликатов.


## 6. Options
Технически, `Option` не является частью Scala коллекций, однако предоставляет похожий интерфейс (с монадическими методами и т.д.) и ведет также как специальный тип коллекций который может иметь, а может не иметь какое-то значение.

Многие из приведенных советов для последовательностей также применимы и к Option. Кроме того, здесь представлены советы характерные для `Option` API.

### 6.1 Значение
#### Не сравнивайте значения Option с `None`

    // До
    option == None
    option != None

    // После
    option.isEmpty
    option.isDefined

В то время как сравнение является вполне законным, у нас есть более простой способ, позволяет проверить объявлен ли `Option`.

Другое преимущество данного упрощения в том, что если вы решите изменить тип от `Option[T]` к `T`, scalac скомпилирует предшествующее выражение (выдав только одно предупреждение), в то время как компиляция последнего, справедливо закончится ошибкой.

#### Не сравнивайте значения `Option` с `Some`

    // До
    option == Some(v)
    option != Some(v)

    // После
    option.contains(v)
    !option.contains(v)

Данный совет является дополнением к предыдущему.

#### Не полагайтесь `isInstanceOf` для проверки наличия элемента

    // До
    option.isInstanceOf[Some[_]]

    // После
    option.isDefined

В подобном трюкачестве нет нужды.

#### Не прибегайте к сопоставлению с образцом, для проверки существования

    // До
    option match {
      case Some(_) => true
      case None => false
    }

    option match {
      case Some(_) => false
      case None => true
    }

    // После
    option.isDefined
    option.isEmpty

Опять же, хотя первое выражение и является корректным, оправдания подобной экстравагантности нет. Кроме того, упрощенное выражение будет работать быстрее.
Также применимо к: `Seq`, `Set`.

#### Не отрицайте значения свойств, связанных с существованием

    // До
    !option.isEmpty
    !option.isDefined
    !option.nonEmpty

    // После
    seq.isDefined
    seq.isEmpty
    seq.isEmpty

Обоснование такое же как и для последовательностей — простое свойство добавляет меньше визуального шума, чем составное выражение.

Заметьте, что у нас есть синонимы: `isDefined` (специфичный для option) и `nonEmpty` (специфичный для последовательностей). Возможно, было бы разумно отдать предпочтение первому, для явного отделения `Option` и последовательностей.


### 6.2 Null
#### Не выполняйте явное сравнение значений с `null` чтобы создать `Option`

    // До
    if (v != null) Some(v) else None

    // После
    Option(v)

Для этого у нас есть специальный и синтаксис.

#### Не предоставляйте `null` как явную альтернативу

    // До
    option.getOrElse(null)

    // После
    option.orNull

В данном случае мы можем полагаться на предопределенный метод, делая выражение короче.


### 6.3 Обработка
Можно выделить группы советов, связанные с тем как обрабатываются значения `Option`.


В [документации](https://www.scala-lang.org/api/current/index.html#scala.Option) посвященной интерфейсу `Option` говорится, что «самый идиоматичный способ использования экземпляра `Option`»: рассмотрение его в качестве коллекции или монады и использование `map`, `flatMap`, `filter` или `foreach`. Основной принцип здесь заключается в том, чтобы избегать "check & get" цепочек, которые обычно реализуются через оператор `if` или сопоставление с образцом.
Целью является надежность и выразительность, «монадический» код:

  * более выразительный и понятный,
  * защищенный от `NoSuchElementException` и `MatchError` ислючений во время
    выполнения

Это объяснение является общим для всех последующих случаев.


#### Не эмулируйте `getOrElse`

    // До
    if (option.isDefined) option.get else z

    option match {
      case Some(it) => it
      case None => z
    }

    // После
    option.getOrElse(z)


#### Не эмулируйте `orElse`

    // До
    if (option1.isDefined) option1 else option2

    option1 match {
      case Some(it) => Some(it)
      case None => option2
    }

    // После
    option1.orElse(option2)


#### Не эмулируйте `exists`

    // До
    option.isDefined && p(option.get)

    if (option.isDefined) p(option.get) else false

    option match {
      case Some(it) => p(it)
      case None => false
    }

    // После
    option.exists(p)


#### Не эмулируйте `forall`

    // До
    option.isEmpty || (option.isDefined && p(option.get))

    if (option.isDefined) p(option.get) else true

    option match {
      case Some(it) => p(it)
      case None => true
    }

    // После
    option.forall(p)


#### Не эмулируйте `contains`

    // До
    option.isDefined && option.get == x

    if (option.isDefined) option.get == x else false

    option match {
      case Some(it) => it == x
      case None => false
    }

    // После
    option.contains(x)


#### Не эмулируйте `foreach`

    // До
    if (option.isDefined) f(option.get)

    option match {
      case Some(it) => f(it)
      case None =>
    }

    // После
    option.foreach(f)


#### Не эмулируйте `filter`

    // До
    if (option.isDefined && p(option.get)) option else None

    option match {
      case Some(it) && p(it) => Some(it)
      case _ => None
    }

    // После
    option.filter(p)


#### Не эмулируйте `map`

    // До
    if (option.isDefined) Some(f(option.get)) else None

    option match {
      case Some(it) => Some(f(it))
      case None => None
    }

    // После
    option.map(f)


#### Не эмулируйте `flatMap`

    // До (f: A => Option[B])
    if (option.isDefined) f(option.get) else None

    option match {
      case Some(it) => f(it)
      case None => None
    }

    // После
    option.flatMap(f)


### 6.4 Перерабатываем
#### Приводим цепочку из `map` и `getOrElse` в `fold`

    // До
    option.map(f).getOrElse(z)

    // После
    option.fold(z)(f)

Данные выражения семантически эквиваленты (в обоих случаях `z` будет вычислен лениво, по требованию), однако последнее выражение короче. Трансформация может требовать дополнительного указания типа (из-за того что вывод типов в Scala так работает), и, в подобных случаях, предыдущее выражение предпочтительнее.

Имейте в виду, что данное упрощение весьма [противоречиво](https://www.reddit.com/r/scala/comments/2z411u/scala_collections_tips_and_tricks/cqiip08/), в виду того что последнее выражение выглядит менее ясно, особенно если вы к нему не привыкли.


#### Не имитируйте `exists`

    // До
    option.map(p).getOrElse(false)

    // После
    option.exists(p)

Мы представили довольно похожее правило для последовательностей (которое также применимо к `Option`-ам). Данная трансформация является специальным случаем вызова `getOrElse`.


#### Не имитируйте `flatten`

    // До (option: Option[Option[T]])
    option.map(_.get)
    option.getOrElse(None)

    // После
    option.flatten

Последнее выражение смотрится чище.


#### Не конвертируйте `Option` в `Seq` вручную

    // До
    option.map(Seq(_)).getOrElse(Seq.empty)
    option.getOrElse(Seq.empty) // option: Option[Seq[T]]

    // После
    option.toSeq

Для этого есть специальный метод, который делает это кратко и эффективно.


## 7. Maps
Так же как и с другими классами коллекций, многие советы для последовательностей также применимы к таблицам, поэтому перечислим только специфичные для таблиц.

#### Не выполняйте поиск значений вручную

    // До
    map.find(_._1 == k).map(_._2)

    // После
    map.get(k)

В принципе, первый фрагмент кода будет работать, однако производительность будет неоптимальной в виду того что `Map` не является простой коллекцией пар (ключ, значение) — она может выполнять поиск в наиболее эффективным способом. Более того, последнее выражение проще и легче для понимания.

#### Не используйте `get`, когда необходимо сырое значение

    // Before
    map.get(k).get

    // After
    map(k)

Нет необходимости плодить промежуточный `Option`, когда необходимо сырое (raw) значение.

#### Не используйте `lift` вместо `get`

    // Before
    map.lift(k)

    // After
    map.get(k)

Нет необходимости рассматривать значение таблицы как частичную функцию для получения опционального результата (что полезно для последовательностей), в виду того что у нас есть встроенный метод с такой же функциональностью. Хотя `lift` отлично работает, он выполняет дополнительное преобразование (от `Map` до` PartialFunction`) и может выглядеть весьма запутанным.

#### Не вызывайте `get` и `getOrElse` раздельно

    // До
    map.get(k).getOrElse(z)

    // После
    map.getOrElse(k, z)

Единственный вызов метода проще, как с синтаксически, так и с точки зрения производительности. В обоих случаях `z` вычисляется лениво, по требованию.

#### Используйте экземпляр Map в качестве объекта-функции

    // До (map: Map[Int, T])
    Seq(1, 2, 3).map(map(_))

    // После
    Seq(1, 2, 3).map(map)

Так как экземпляр Map[K, V] также является Function1[K, V], вы можете использовать его как функцию.

#### Не извлекайте ключи вручную

    // До
    map.map(_._1)
    map.map(_._1).toSet
    map.map(_._1).toIterator

    // После
    map.keys
    map.keySet
    map.keysIterator

Оптимизированные выражения являются более понятными (и потенциально более быстрыми).


#### Не извлекайте значения вручную

    // До
    map.map(_._2)
    map.map(_._2).toIterator

    // После
    map.values
    map.valuesIterator

Упрощенные выражения понятней (и потенциально быстрее).


#### Будьте осторожны с `filterKeys`

    // До
    map.filterKeys(p)

    // После
    map.filter(p(_._1))

Метод `filterKeys` обертывает исходную таблицу без копирования каких-либо элементов. В этом нет ничего плохого, однако подобное поведение от `filterKeys` вряд ли ожидается. Поскольку оно неожиданно ведет сродни представлению, производительность кода может быть существенно снижена для некоторых случаев, например для `filterKeys(p).groupBy(???)`.

Другой вероятной неприятностью является неожиданная «ленивость» (по умолчанию фильтры коллекций должны быть строгими) – при вызове самого метода предикат вообще не вычисляется, из-за чего возможные побочные эффекты могут быть переупорядочены.

Метод `filterKeys`, скорее всего, следовало бы объявить устаревшим, из-за невозможности [сделать его строгим](https://issues.scala-lang.org/browse/SI-4776) не сломав обратную совместимость. Более подходящим именем для текущей реализации будет `withKeyFilter` (по аналогии с `withFilter`).

В общем, вполне разумным будет следовать [Правилу наименьшего удивления](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) и фильтровать ключи вручную.

Тем не менее, поскольку схожая с представлением функциональность `filterKeys` потенциально полезна (когда доступ будет только к небольшому числу записей, в то время как таблица будет относительно большой), мы все же сможем рассмотреть возможность использования этого метода.

Для того чтобы не вводить в заблуждение людей, читающих (или модифицирующих) наш код, лучшим решением будет подчеркнуть наши намерения объявив подходящий синоним:

    type MapView[A, +B] = Map[A, B]

    implicit class MapExt[A, +B](val map: Map[A, B]) extends AnyVal {
      def withKeyFilter(p: A => Boolean): MapView[A, B] =
        map.filterKeys(p)
    }

Мы используем псевдоним типа `MapView` для того чтобы обозначить что результирующая таблица является view-подобной. Другим вариантом будет объявление простого вспомогательного метода:

    def get(k: T) = if (p(k)) map.get(k) else None


#### Будьте осторожны с `mapValues`

    // До
    map.mapValues(f)

    // После
    map.map(f(_._2))

Обоснование такое же как и в предыдущем случае. Аналогичным способом мы можем объявить недвусмысленный синоним:

    type MapView[A, +B] = Map[A, B]

    implicit class MapExt[A, +B](val map: Map[A, B]) extends AnyVal {
      def withValueMapper[C](f: B => C): MapView[A, C] =
        map.mapValues(f)
    }

Проще объявить вспомогательный метод вроде:

    def get(k: T) = map.get(k).map(f)

#### Не отфильтровывайте ключи вручную

    // До
    map.filterKeys(!seq.contains(_))

    // После
    map -- seq

Мы можем полагаться на упрощенный синтаксис, чтобы отфильтровать ключи.

#### Используйте операторы переприсваивания таблиц

    // До
    map = map + x -> y
    map1 = map1 ++ map2
    map = map - x
    map = map -- seq

    // После
    map += x -> y
    map1 ++= map2
    map -= x
    map --= seq

Также как и с последовательностями, мы можем полагаться на синтаксический сахар, для упрощения подобных операторов.


## 8. Дополнение
В дополнение к приведенным рецептам, я рекомендую вам посмотреть на официальную [документацию библиотеки коллекций Scala](http://docs.scala-lang.org/overviews/collections/introduction.html), которую, на удивление легко читать.

Смотрите также:

  * [Scala for Project Euler](https://pavelfatin.com/scala-for-project-euler/) — Выразительные функциональные решения проблем проекта Эйлер на Scala.
  * [Ninety-nine](https://pavelfatin.com/ninety-nine/) — Девяносто девять проблем на Scala, Java, Clojure и Haskell (с множеством решений).

Данные головоломки неоценимо помогли мне сформировать и углубить мое понимание коллекций Scala.

Несмотря на обширность данного списка, он наверняка далек от завершения. Более того, в виду сильно варьирующейся применимости данных рецептов, некоторая тонкая настройка определенно необходима. Ваши предложения приветствуются.
